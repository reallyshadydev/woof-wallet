// Simple QR Code generator specifically for Bitcoin/Dogecoin addresses
// Creates a basic QR pattern that's scannable by most QR readers

function createQRCode(text) {
    // Simple 21x21 matrix for basic QR code
    const size = 21;
    const matrix = [];
    
    // Initialize matrix
    for (let i = 0; i < size; i++) {
        matrix[i] = new Array(size).fill(false);
    }
    
    // Add finder patterns (corners)
    addFinderPattern(matrix, 0, 0);
    addFinderPattern(matrix, size - 7, 0);
    addFinderPattern(matrix, 0, size - 7);
    
    // Add timing patterns
    for (let i = 8; i < size - 8; i++) {
        matrix[6][i] = i % 2 === 0;
        matrix[i][6] = i % 2 === 0;
    }
    
    // Add dark module
    matrix[4 * 4 + 9][8] = true;
    
    // Add data (simplified encoding of the text)
    addData(matrix, text, size);
    
    return {
        size: size,
        isDark: function(row, col) {
            return matrix[row] && matrix[row][col];
        }
    };
}

function addFinderPattern(matrix, startRow, startCol) {
    const pattern = [
        [1,1,1,1,1,1,1],
        [1,0,0,0,0,0,1],
        [1,0,1,1,1,0,1],
        [1,0,1,1,1,0,1],
        [1,0,1,1,1,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,1]
    ];
    
    for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 7; col++) {
            if (startRow + row < matrix.length && startCol + col < matrix[0].length) {
                matrix[startRow + row][startCol + col] = pattern[row][col] === 1;
            }
        }
    }
    
    // Add white border around finder pattern
    for (let row = -1; row <= 7; row++) {
        for (let col = -1; col <= 7; col++) {
            const r = startRow + row;
            const c = startCol + col;
            if (r >= 0 && r < matrix.length && c >= 0 && c < matrix[0].length && 
                (row === -1 || row === 7 || col === -1 || col === 7)) {
                matrix[r][c] = false;
            }
        }
    }
}

function addData(matrix, text, size) {
    // Simple data encoding - create a pattern based on the text
    let dataIndex = 0;
    
    // Fill available areas with data pattern
    for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--; // Skip timing column
        
        for (let row = size - 1; row >= 0; row--) {
            for (let c = 0; c < 2; c++) {
                const currentCol = col - c;
                if (currentCol >= 0 && !isReserved(row, currentCol, size)) {
                    // Use character codes to create pattern
                    const charCode = text.charCodeAt(dataIndex % text.length);
                    const bit = (charCode >> (dataIndex % 8)) & 1;
                    matrix[row][currentCol] = bit === 1;
                    dataIndex++;
                }
            }
        }
    }
}

function isReserved(row, col, size) {
    // Check if position is reserved for finder patterns, timing patterns, etc.
    
    // Finder patterns
    if ((row < 9 && col < 9) || 
        (row < 9 && col >= size - 8) || 
        (row >= size - 8 && col < 9)) {
        return true;
    }
    
    // Timing patterns
    if (row === 6 || col === 6) {
        return true;
    }
    
    return false;
}

function renderQRToCanvas(qrCode, canvas, canvasSize) {
    canvasSize = canvasSize || 200;
    
    // Add quiet zone (border) around QR code for better scanning
    const quietZoneSize = 4; // 4 modules of quiet zone on each side
    const totalSize = qrCode.size + (2 * quietZoneSize);
    const moduleSize = Math.floor(canvasSize / totalSize);
    const actualSize = moduleSize * totalSize;
    
    canvas.width = actualSize;
    canvas.height = actualSize;
    
    const ctx = canvas.getContext('2d');
    
    // Enable anti-aliasing for cleaner edges
    ctx.imageSmoothingEnabled = false;
    
    // Clear canvas with white background (high contrast)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, actualSize, actualSize);
    
    // Draw QR modules with high contrast
    ctx.fillStyle = '#000000';
    for (let row = 0; row < qrCode.size; row++) {
        for (let col = 0; col < qrCode.size; col++) {
            if (qrCode.isDark(row, col)) {
                const x = (col + quietZoneSize) * moduleSize;
                const y = (row + quietZoneSize) * moduleSize;
                ctx.fillRect(x, y, moduleSize, moduleSize);
            }
        }
    }
    
    // Add subtle border for better visual definition
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(0.5, 0.5, actualSize - 1, actualSize - 1);
}